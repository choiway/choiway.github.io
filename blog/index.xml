<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Wayne Choi</title>
    <link>https://choiway.github.io/blog/</link>
    <description>Recent content in Blogs on Wayne Choi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Nov 2019 00:25:35 -0800</lastBuildDate>
    
	<atom:link href="https://choiway.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>BEaM Stack</title>
      <link>https://choiway.github.io/beam-stack/</link>
      <pubDate>Thu, 28 Nov 2019 00:25:35 -0800</pubDate>
      
      <guid>https://choiway.github.io/beam-stack/</guid>
      <description>The BEaM stack: Browser, Email and Messages. I recently helped somebody think through a mobile solution to a problem. The one thing that came up again and again is that people are doing more on mobile devices but nobody wants to download an app anymore. Our solution: use the browser, email and messaging&amp;hellip;all of which are available on all mobile phones today.
A couple things I took away from prototyping the app:</description>
    </item>
    
    <item>
      <title>Data Objects</title>
      <link>https://choiway.github.io/data-objects/</link>
      <pubDate>Thu, 26 Sep 2019 13:14:12 -0700</pubDate>
      
      <guid>https://choiway.github.io/data-objects/</guid>
      <description>Object oriented programming (&amp;ldquo;OOP&amp;rdquo;) gets a bad rap. Some of it is deserved but OOP does shines when you need to manage state. Check out genservers in Erlang to see the hoops you have to go through to manage state.
You can avoid some of the pitfalls of OOP if you draw hard lines between state and data. One of the ways to draw a hard line between state and data is to only create methods in a class that operate on the objects state and returns the result.</description>
    </item>
    
    <item>
      <title>State Is Not Data</title>
      <link>https://choiway.github.io/state-is-not-data/</link>
      <pubDate>Wed, 25 Sep 2019 22:23:14 -0700</pubDate>
      
      <guid>https://choiway.github.io/state-is-not-data/</guid>
      <description>Differentiating between data and state leads to cleaner code. What&amp;rsquo;s the difference? When you instantiate and object with data you create an object with state.
class User { constructor(dataJson) { this.fname = dataJson.fname; this.lname = dataJson.lname; } } newUser = new User({fname: &amp;#34;Jack&amp;#34;, lname: &amp;#34;Frost&amp;#34;})  The object newUser is an object with the state fname = Jack and lname = Frost. Data, in this example, is the json object.</description>
    </item>
    
    <item>
      <title>Gradual Types In Elixir</title>
      <link>https://choiway.github.io/gradual-types-in-elixir/</link>
      <pubDate>Tue, 21 Aug 2018 15:22:37 -0700</pubDate>
      
      <guid>https://choiway.github.io/gradual-types-in-elixir/</guid>
      <description>Elixir isn&amp;rsquo;t a statically typed language but with structs, schemas, and pattern matching along with a robust, built-in test suite you have a toolbox that allows for gradual typing.
To illustrate gradual typing we&amp;rsquo;ll walk through an example of creating a user login with the parameters username, email_address and age. For this example, we&amp;rsquo;ll print a message with parameters: username: #{params[&amp;quot;username&amp;quot;]}, email_address: #{params[&amp;quot;email_address&amp;quot;]}, next_year_age: #{next_year_age} where next_year_age is age plus one.</description>
    </item>
    
    <item>
      <title>Using Genetic Algorithms To Search For Trading Signals</title>
      <link>https://choiway.github.io/using-genetic-algorithms-to-search-for-trading-signals/</link>
      <pubDate>Mon, 16 Jul 2018 15:05:02 -0700</pubDate>
      
      <guid>https://choiway.github.io/using-genetic-algorithms-to-search-for-trading-signals/</guid>
      <description>Motivation When applying machine learning to financial markets most quantitative research focus on optimization algorithms for user defined features. This approach raises two issues. One is that the user needs to have deep domain knowledge in order to generate and define features. The second, related issue occurs when the act of gaining domain knowledge prejudices the researcher about what features may or may not work. In this walkthrough, we consider an alternative approach where we start with the assumption that the researcher has no knowledge of what works but in the entire universe of trading strategies there is a strategy that does work.</description>
    </item>
    
  </channel>
</rss>